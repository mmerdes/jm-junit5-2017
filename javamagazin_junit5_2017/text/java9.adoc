==== #WorksFineOnJDK9

JUnit 5 unterstützt seit der Version 5.0.0 die Verwendung unter Java 9.
Einerseits wird keine verbotene und bald unerreichbare Java API, wie `sun.misc.Unsafe` oder andere _Illegal Reflective Access_ Hacks, verwendet.
Andererseits enthalten alle veröffentlichten Artefakte ein eindeutiges `Automatic-Module-Name` Attribut in ihrem JAR Manifest.
So ist zum Beispiel in der Datei `junit-jupiter-api-5.0.0.jar` der Modulname `org.junit.jupiter.api` festgehalten.
Unter diesem "reverse DNS" Namen kann man unter Java 9 das Jupiter API Modul eindeutig referenzieren.

```java
open module com.foo.bar {
  requires org.junit.jupiter.api;
}
```

Zur Zeit sind die JUnit 5 Artefakte nur als "automatische Module" verwendbar.
Das heißt, sie enthalten keine konkrete Modulbeschreibungsklasse namens `module-info.class`.
Damit sind automatisch alle Pakete eines Artefakts les- und verwendbar, auch die, die wir nicht öffentlich verfügbar machen wollen.
Das wird sich in einer zukünftigen JUnit 5 Version ändern.
Deshalb bitte keine mit `@API(Status.INTERNAL)` annotierte Klasse verwenden.

==== Tests in Modulen organisieren

Zwei Arten von Tests:

* Modul-interne Tests, genau früher auf dem `class-path`, mit Zugriff auf `package private` und `protected` deklarierte Typen.
* User-view Tests: nur Zugriff auf die exportierten Typen, die strikten Modulgrenzen werden respektiert

Ausführung mittels `ConsoleLauncher`...

`--select-module com.foo.bar` und `--select-module-path`

// Ideen aus `junit5-java9-modulepath` holen bzw. beschreiben

https://github.com/junit-team/junit5-samples/pull/46/files

==== Die Eismaschine

Oder wie implementiert und registriert man eine eigene `TestEngine` mit Java 9?

// Text aus `junit5-java9-engine` übersetzen

https://github.com/junit-team/junit5-samples/blob/master/junit5-java9-engine/README.md
