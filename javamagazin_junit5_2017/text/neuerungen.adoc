
== Wesentliche Neuerungen


include::displayname.adoc[]

include::nested_tests.adoc[]

include::dynamic_tests.adoc[]

include::param_injection.adoc[]



=== Tags und Meta-Annotations

Eine weitere Veränderung im Vergleich zu JUnit 4 ist das Tagging von Tests mit bestimmten Labeln,
was in JUnit 5 String-basiert und nicht mehr über den klassen-basierten Category-Mechanismus gelöst ist.

image::images/tagging.png[]

Möchte man nun für eine Menge von Tests (z.B. für alle Integrationstests) ein solches Tag vergeben,
so kann es sinnvoll sein, sich eines neu eingeführten Mechanismus' zu bedienen.
So wird nämlich für alle im Jupiter-API vorhandenen Annotationen eine Komposition von Annotationen zu Meta-Annotationen unterstützt.
Ähnliche Mechanismen sind wieder aus dem Spring Framework oder auch aus der Programmiersprache Groovy bekannt.

image::images/tagging.png[]

Im Beispiel werden besonders schnell ausführbare Tests durch die Meta-Annotation @FastTest gekennzeichnet,
z.B. weil man sie aus Fast-Feedback-Gründen im Build zuerst ausführen möchte.
Mit diesem Mechanismus lassen sich Möglichkeiten der Jupiter-API parametrisieren und zu höherwertigen Abstraktionen zusammenfassen,
was der konsistenten Verwendung z.B. durch verschiedene Testautoren im Team dienen kann.


=== Extensions

Das hybride Erweiterungsmodell von JUnit 4 aus Runner und Rule hatte sich über die Jahre hinweg
insbesondere im Bereich der Komponierbarkeit als problematisch herausgestellt.
Daher wurde bei JUnit 5 viel Energie darauf verwendet,
ein sowohl einheitliches als auch ausdrucksmächtiges Erweiterungsmodell zu entwerfen und umzusetzen.
Es handelt sich dabei um ein feingranulares Erweiterungsmodell,
das einen selektiven Eingriff an vielen Stellen der Testdefinition und -ausführung erlaubt.
Insbesondere sind die Erweiterungen aus technischer Sicht beliebig kombinierbar.
Diesem Thema ließe sich leicht ein ganzer Artikel widmen,
hier soll nur kurz an Hand eines Beispiels die Grundidee erläutert werden.

image::images/mockito_extension_diagram.png[]

Als Basis aller Erweiterungen für JUnit Jupiter gibt es das Marker-Interface 'Extension'.
Nehmen wir nun an, dass eine einfache Extension zur Integration des Mockframeworks Mockito erstellt werden soll.
Konkret müsste eine solche 'MockitoExtension' die beiden ExtensionPoints
'TestInstancePostProcessor' und 'ParameterResolver' implementieren,
wenn man die Extension dann wie in Abbildung XXXXX verwenden will.
Beide ExtensionPoints erweitern wiederum das genannte Marker-Interface.

image::images/mockito_extension_code.png[]

In diesem Beispiel wird der ExtensionPoint 'TestInstancePostProcessor' benötigt,
um über das Mockito-API die Mocks direkt nach Erstellung der Testinstanz zu initialisieren.
Der ExtensionPoint 'ParameterResolver' hingegen dient dazu,
die so erzeugten Mocks elegant in die gewünschten Test- oder Lifecycle-Methoden hineinreichen zu können,
was präzise ausdrücken lässt, für welche Methoden welche Mocks bestimmt sind.

Neben den beiden hier genannten ExtensionPoints gibt es eine ganz Reihe anderer,
etwa zur Handhabung von Ausnahmen und insbesondere zur Interaktion mit den benutzerdefinierten Methoden des Test-Lifecycle
(z.b. @BeforeAll und BeforeAllCallback).

Zusammenfassend lasst sich sagen,
dass man entweder auf einer sehr hohen Abstraktionsebene eine eigene Testengine implementieren kann
oder aber die Standard-Testengine 'Jupiter' durch feingranulare und komponierbare Extensions erweitern kann.
Eine Kombination von eigener Engine und Jupiter-Extensions funktioniert natürlich auch in JUnit 5 nicht.
Dies liegt aber in der Natur der Sache,
da ein Erweiterungsmodell notwendigerweise die Abstraktionen einer konkreten Engine manipulierbar machen muss
und sich nicht sinnvoll allgemein über alle Engines hinweg modellieren lässt.
